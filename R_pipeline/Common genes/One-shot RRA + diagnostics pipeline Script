# =============================================================
# One-shot RRA + diagnostics pipeline 
# Tailored for Neuroblastoma datasets
# =============================================================

# ---------- CONFIG ----------
base_dir <- "E:/R/RStudio/R CLASS/Data/Text file for RRA/Neuroblastoma"
setwd(base_dir)

files <- c("your datasets.txt")
out_prefix <- "Neuroblastoma_"

# If your files were truncated (only DEG subset), set universe_N manually (e.g. 20000)
universe_N <- 20000

# Auto-flip settings
auto_flip <- TRUE
flip_threshold <- 0.15

# ---------- PACKAGES ----------
pkgs <- c("dplyr","readr","RobustRankAggreg","openxlsx")
for(p in pkgs) if(!requireNamespace(p, quietly=TRUE)) stop("Install package: ", p)
library(dplyr); library(readr); library(RobustRankAggreg); library(openxlsx)

# ---------- HELPERS ----------
read_deg_txt <- function(path) {
  df <- tryCatch(read_delim(path, delim = "\t", show_col_types = FALSE),
                 error = function(e) tryCatch(read_delim(path, delim = " ", show_col_types = FALSE),
                                              error = function(e2) read.table(path, header = TRUE, sep = "", stringsAsFactors = FALSE)))
  names(df) <- gsub("^\\s+|\\s+$", "", names(df))
  gene_col <- intersect(c("Gene","Gene.symbol","SYMBOL","gene","ID"), names(df))[1]
  if (is.na(gene_col) || is.null(gene_col)) stop("No gene column detected in ", path)
  df <- df %>% rename(Gene.symbol = all_of(gene_col))
  if ("logFC" %in% names(df)) df <- df %>% rename(logFC = logFC)
  else if ("log2FoldChange" %in% names(df)) df <- df %>% rename(logFC = log2FoldChange)
  else df$logFC <- NA_real_
  if ("adj.P.Val" %in% names(df)) df <- df %>% rename(adj.P.Val = adj.P.Val)
  else if ("padj" %in% names(df)) df <- df %>% rename(adj.P.Val = padj)
  else df$adj.P.Val <- NA_real_
  df <- df %>% mutate(Gene.symbol = as.character(Gene.symbol)) %>% filter(!is.na(Gene.symbol))
  df <- df %>% distinct(Gene.symbol, .keep_all = TRUE)
  return(as.data.frame(df))
}

make_ranked_vectors <- function(df) {
  if (any(!is.na(df$logFC))) {
    up <- df %>% arrange(desc(logFC), adj.P.Val) %>% pull(Gene.symbol)
    down <- df %>% arrange(logFC, adj.P.Val) %>% pull(Gene.symbol)
  } else {
    up <- df$Gene.symbol
    down <- rev(df$Gene.symbol)
  }
  up <- unique(up[!is.na(up)]); down <- unique(down[!is.na(down)])
  list(up=up, down=down)
}

attach_meta <- function(rra_obj, mat) {
  tmp <- as.data.frame(rra_obj)
  tmp2 <- dplyr::left_join(tmp, data.frame(Gene.symbol = rownames(mat), mat, stringsAsFactors = FALSE), by = c("Name" = "Gene.symbol"))
  logfc_cols <- intersect(colnames(mat), colnames(tmp2))
  meta <- t(apply(tmp2[, logfc_cols, drop=FALSE], 1, function(x) {
    nobs <- sum(!is.na(x))
    mean_fc <- if(nobs==0) NA else mean(x, na.rm=TRUE)
    pct_up <- if(nobs==0) NA else sum(x>0, na.rm=TRUE)/nobs
    consensus <- if(is.na(pct_up)) NA else if(pct_up==1) "consistent_up" else if(pct_up==0) "consistent_down" else "mixed"
    c(n_datasets = nobs, mean_fc = round(mean_fc,3), pct_up = round(pct_up,3), consensus = consensus)
  }))
  meta <- as.data.frame(meta, stringsAsFactors = FALSE)
  meta$n_datasets <- as.integer(meta$n_datasets)
  meta$mean_fc <- as.numeric(meta$mean_fc)
  meta$pct_up <- as.numeric(meta$pct_up)
  return(bind_cols(tmp2, meta))
}

# ---------- READ & PREP ----------
gse_names <- tools::file_path_sans_ext(basename(files))
gse_list <- list(); glist_up <- list(); glist_down <- list(); measured_genes <- character(0)

for (i in seq_along(files)) {
  f <- files[i]
  if (!file.exists(f)) stop("File not found: ", f)
  gse_list[[gse_names[i]]] <- read_deg_txt(f)
  r <- make_ranked_vectors(gse_list[[gse_names[i]]])
  glist_up[[gse_names[i]]] <- r$up
  glist_down[[gse_names[i]]] <- r$down
  measured_genes <- union(measured_genes, gse_list[[gse_names[i]]]$Gene.symbol)
  cat("Loaded", gse_names[i], "- genes:", nrow(gse_list[[gse_names[i]]]), " logFC present:", any(!is.na(gse_list[[gse_names[i]]]$logFC)), "\n")
}

# ---------- UNIVERSE ----------
if (!is.null(universe_N)) {
  N <- as.integer(universe_N); cat("Using user-provided N =", N, "\n")
} else {
  N <- length(unique(measured_genes)); cat("Computed universe N =", N, "\n")
}

# ---------- RUN RRA ----------
run_rra_and_mat <- function(glist_up, glist_down, gse_list) {
  rra_up <- aggregateRanks(glist = glist_up, N = N)
  rra_down <- aggregateRanks(glist = glist_down, N = N)
  rra_up$Adjusted_P <- p.adjust(rra_up$Score, method = "fdr")
  rra_down$Adjusted_P <- p.adjust(rra_down$Score, method = "fdr")
  all_genes_all <- unique(unlist(lapply(gse_list, function(x) x$Gene.symbol)))
  mat <- matrix(NA_real_, nrow = length(all_genes_all), ncol = length(gse_list),
                dimnames = list(all_genes_all, names(gse_list)))
  for (nm in names(gse_list)) {
    df <- gse_list[[nm]]
    if ("logFC" %in% colnames(df) && any(!is.na(df$logFC))) {
      idx <- match(df$Gene.symbol, rownames(mat)); valid <- which(!is.na(idx))
      mat[idx[valid], nm] <- df$logFC[valid]
    }
  }
  list(rra_up=rra_up, rra_down=rra_down, mat=mat)
}

res <- run_rra_and_mat(glist_up, glist_down, gse_list)
rra_up <- res$rra_up; rra_down <- res$rra_down; mat <- res$mat

# ---------- AUTO-FLIP DIAGNOSTICS ----------
compute_mean_pairwise <- function(m) {
  cm <- cor(m, use = "pairwise.complete.obs")
  if (ncol(cm) < 2) return(NA)
  mean(cm[upper.tri(cm)], na.rm = TRUE)
}
cat("\nInitial pairwise correlations (rounded):\n"); print(round(cor(mat, use = "pairwise.complete.obs"), 2))
base_mean_corr <- compute_mean_pairwise(mat)
cat("Initial mean pairwise corr:", round(base_mean_corr,3), "\n")

flip_gain <- sapply(colnames(mat), function(nm) {
  mf <- mat; mf[, nm] <- -mf[, nm]
  new_mean <- compute_mean_pairwise(mf)
  new_mean - base_mean_corr
})
print(round(flip_gain, 3))

flipped <- character(0)
if (auto_flip) {
  for(nm in names(flip_gain)) {
    if (!is.na(flip_gain[nm]) && flip_gain[nm] > flip_threshold) {
      cat("Auto-flipping", nm, "(gain =", round(flip_gain[nm],3), ")\n")
      gse_list[[nm]]$logFC <- -gse_list[[nm]]$logFC
      rv <- make_ranked_vectors(gse_list[[nm]])
      glist_up[[nm]] <- rv$up; glist_down[[nm]] <- rv$down
      flipped <- c(flipped, nm)
    }
  }
  if (length(flipped) > 0) {
    cat("Re-running RRA after flips:", paste(flipped, collapse=", "), "\n")
    res <- run_rra_and_mat(glist_up, glist_down, gse_list)
    rra_up <- res$rra_up; rra_down <- res$rra_down; mat <- res$mat
    cat("New pairwise correlations (rounded):\n"); print(round(cor(mat, use = "pairwise.complete.obs"), 2))
    cat("New mean pairwise corr:", round(compute_mean_pairwise(mat), 3), "\n")
  } else cat("No dataset passed flip threshold (no auto-flips).\n")
}

# ---------- OUTPUT TABLES ----------
target_gses <- c("your datasets")

get_logfc_padj <- function(mat, gse_list, target_gses) {
  all_genes <- rownames(mat)
  logfc_df <- data.frame(Gene.symbol = all_genes, stringsAsFactors = FALSE)
  padj_df <- data.frame(Gene.symbol = all_genes, stringsAsFactors = FALSE)
  for (g in target_gses) {
    logfc_col <- paste0("logfc ", g)
    padj_col  <- paste0("adj.p ", g)
    if (g %in% colnames(mat)) logfc_df[[logfc_col]] <- mat[, g]
    else logfc_df[[logfc_col]] <- NA_real_
    if (g %in% names(gse_list)) {
      df <- gse_list[[g]]
      padj_df[[padj_col]] <- df$adj.P.Val[match(all_genes, df$Gene.symbol)]
    } else padj_df[[padj_col]] <- NA_real_
  }
  list(logfc = logfc_df, padj = padj_df)
}

meta_info <- get_logfc_padj(mat, gse_list, target_gses)
logfc_df <- meta_info$logfc
padj_df  <- meta_info$padj

build_final_table <- function(rra_obj) {
  tmp <- as.data.frame(rra_obj)
  merged <- left_join(tmp, logfc_df, by = c("Name" = "Gene.symbol"))
  merged <- left_join(merged, padj_df, by = c("Name" = "Gene.symbol"))
  log_cols <- paste0("logfc ", target_gses)
  merged$mean_fc <- apply(merged[, log_cols, drop = FALSE], 1, function(x)
    if (all(is.na(x))) NA else round(mean(x, na.rm = TRUE), 3))
  merged$n_datasets <- apply(merged[, log_cols, drop = FALSE], 1, function(x) sum(!is.na(x)))
  merged$pct_up <- apply(merged[, log_cols, drop = FALSE], 1, function(x) {
    n <- sum(!is.na(x)); if (n==0) return(NA); round(sum(x > 0, na.rm = TRUE) / n, 3)
  })
  merged$consensus <- apply(merged[, log_cols, drop = FALSE], 1, function(x) {
    n <- sum(!is.na(x)); if (n==0) return(NA_character_)
    if (sum(x > 0, na.rm = TRUE) == n) return("consistent_up")
    if (sum(x < 0, na.rm = TRUE) == n) return("consistent_down")
    "mixed"
  })
  adj_cols <- paste0("adj.p ", target_gses)
  ordered_cols <- c("Name", "Score", "Adjusted_P", log_cols, "mean_fc", adj_cols,
                    "n_datasets", "pct_up", "consensus")
  merged[, ordered_cols[ordered_cols %in% names(merged)], drop = FALSE]
}

rra_up_out_final   <- build_final_table(rra_up)
rra_down_out_final <- build_final_table(rra_down)

wb <- createWorkbook()
addWorksheet(wb, "RRA_up")
addWorksheet(wb, "RRA_down")
writeData(wb, "RRA_up", rra_up_out_final)
writeData(wb, "RRA_down", rra_down_out_final)
saveWorkbook(wb, paste0(out_prefix, "_RRA_results_final.xlsx"), overwrite = TRUE)

# ---------- SUMMARY ----------
cat("\n=== PIPELINE FINISHED ===\n")
cat("Files created:\n -", paste0(out_prefix, "_RRA_results_final.xlsx"), "\n")
cat("\nSummary:\n")
cat("Universe N:", N, "\n")
cat("Datasets auto-flipped (if any):", if(length(flipped)>0) paste(flipped, collapse=", ") else "NONE", "\n")
sessionInfo()
