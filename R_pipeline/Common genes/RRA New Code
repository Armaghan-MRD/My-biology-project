# ============================================================
# RRA Analysis & Heatmaps (Corrected, Reproducible)
# Author: Armaghan Moradi
# Purpose: create ranked lists, run RRA, merge per-GSE logFCs, and plot heatmaps
# ============================================================

# --- Libraries ---
library(RobustRankAggreg)
library(readxl)
library(dplyr)
library(tidyr)
library(pheatmap)
library(openxlsx)   # to write Excel workbook
options(stringsAsFactors = FALSE)

# --- User params: adjust these as needed ---
up_file   <- "E:/R/RStudio/R CLASS/Data/AML up-down/All_Upregulated.xlsx"
down_file <- "E:/R/RStudio/R CLASS/Data/AML up-down/All_Downregulated.xlsx"
out_prefix <- "AML"
setwd("E:/R/RStudio/R CLASS/Data/AML up-down/")

# Optional per-dataset filtering before ranking (recommended to try both FALSE and TRUE)
apply_filter <- FALSE
padj_cut <- 0.05
abslogfc_cut <- 1

# Names of the three sheets (modify if different)
sheets <- c("", "", "")



# ============================================================
# 1) Helper: read one dataset (up/down) returning a dataframe
# Expect columns: Gene.symbol (or Gene.symbol), logFC, adj.P.Val (or similar)
# ============================================================
read_and_standardize <- function(file, sheet) {
  df <- read_excel(file, sheet = sheet)
  # Try to standardize to consistent column names:
  colnames(df) <- gsub("^\\s+|\\s+$", "", colnames(df)) # trim
  # Accept variations: Gene.symbol OR SYMBOL OR Gene
  if ("Gene.symbol" %in% colnames(df)) genecol <- "Gene.symbol"
  else if ("SYMBOL" %in% colnames(df)) genecol <- "SYMBOL"
  else if ("Gene" %in% colnames(df)) genecol <- "Gene"
  else stop(paste("No gene symbol column found in", sheet))
  # logFC detection
  if ("logFC" %in% colnames(df)) logcol <- "logFC"
  else if ("log2FoldChange" %in% colnames(df)) logcol <- "log2FoldChange"
  else logcol <- NA
  # adjusted p-value detection
  if ("adj.P.Val" %in% colnames(df)) padjcol <- "adj.P.Val"
  else if ("padj" %in% colnames(df)) padjcol <- "padj"
  else if ("adj.P" %in% colnames(df)) padjcol <- "adj.P"
  else padjcol <- NA
  # Keep only relevant columns and rename
  out <- df %>% rename(Gene.symbol = all_of(genecol))
  if (!is.na(logcol)) out <- out %>% rename(logFC = all_of(logcol))
  if (!is.na(padjcol)) out <- out %>% rename(adj.P.Val = all_of(padjcol))
  # Ensure unique gene symbols (keep first appearance)
  out <- out %>% filter(!is.na(Gene.symbol)) %>% distinct(Gene.symbol, .keep_all = TRUE)
  return(out)
}

# ============================================================
# 2) Load all DEG tables (up + down) per GSE into dataframes
#    We'll create combined DE tables per GSE (up + down sheets concatenated)
# ============================================================

gse_de <- list()
for (s in sheets) {
  up_df   <- read_and_standardize(up_file, s)
  down_df <- read_and_standardize(down_file, s)
  # Combine; if both contain same gene, keep the one with non-NA logFC preferring up sheet first
  combined <- bind_rows(up_df, down_df) %>%
    group_by(Gene.symbol) %>% slice(1) %>% ungroup()
  gse_de[[s]] <- combined
}

# ============================================================
# 3) Optional filtering before ranking (toggle apply_filter)
#    If TRUE, keep only genes meeting adj.P.Val and logFC criteria per dataset
#    If FALSE, we will use full lists (but ranked)
# ============================================================
for (s in sheets) {
  df <- gse_de[[s]]
  if (apply_filter) {
    if (!("adj.P.Val" %in% colnames(df))) {
      warning(paste0("No adj.P.Val in ", s, " — skipping filter for this sheet."))
    } else {
      df <- df %>% filter(!is.na(adj.P.Val) & adj.P.Val <= padj_cut & !is.na(logFC) & abs(logFC) >= abslogfc_cut)
    }
  }
  # Save back
  gse_de[[s]] <- df
}

# ============================================================
# 4) Create ranked vectors (ordered character vectors) for RRA
#    Rank by adj.P.Val ascending (more significant first), tie-breaker: absolute logFC desc
# ============================================================
make_ranked_vector <- function(df) {
  # If adj.P.Val exists, rank by adj.P.Val (asc) then abs(logFC) desc; else try rank by -abs(logFC)
  if ("adj.P.Val" %in% colnames(df)) {
    df2 <- df %>% arrange(adj.P.Val, desc(abs(ifelse(is.na(logFC), 0, logFC))))
  } else if ("logFC" %in% colnames(df)) {
    df2 <- df %>% arrange(desc(abs(logFC)))
  } else {
    df2 <- df
  }
  return(df2$Gene.symbol)
}

glist_up  <- list()
glist_down <- list()
for (s in sheets) {
  df <- gse_de[[s]]
  # Separate up and down by sign of logFC if logFC available, else use all as "up" lists (fall back)
  if ("logFC" %in% colnames(df)) {
    up_genes  <- df %>% filter(!is.na(logFC) & logFC > 0)
    down_genes <- df %>% filter(!is.na(logFC) & logFC < 0)
  } else {
    # if no logFC column present, treat entire sheet as ranked list (this is less ideal)
    up_genes <- df
    down_genes <- df
  }
  glist_up[[s]]    <- make_ranked_vector(up_genes)
  glist_down[[s]]  <- make_ranked_vector(down_genes)
}

# Check overlap just for sanity
cat("Intersections (up lists):\n")
cat("intersect(", sheets[1], ",", sheets[2], ") =", length(intersect(glist_up[[sheets[1]]], glist_up[[sheets[2]]])), "\n")
cat("intersect(", sheets[2], ",", sheets[3], ") =", length(intersect(glist_up[[sheets[2]]], glist_up[[sheets[3]]])), "\n")
cat("intersect(", sheets[1], ",", sheets[3], ") =", length(intersect(glist_up[[sheets[1]]], glist_up[[sheets[3]]])), "\n\n")

cat("Intersections (down lists):\n")
cat("intersect(", sheets[1], ",", sheets[2], ") =", length(intersect(glist_down[[sheets[1]]], glist_down[[sheets[2]]])), "\n")
cat("intersect(", sheets[2], ",", sheets[3], ") =", length(intersect(glist_down[[sheets[2]]], glist_down[[sheets[3]]])), "\n")
cat("intersect(", sheets[1], ",", sheets[3], ") =", length(intersect(glist_down[[sheets[1]]], glist_down[[sheets[3]]])), "\n\n")

# ============================================================
# 5) Universe size N and run RRA
# ============================================================
all_genes <- unique(c(unlist(glist_up), unlist(glist_down)))
N <- length(all_genes)
k_up <- length(glist_up)
k_down <- length(glist_down)

rra_up <- aggregateRanks(glist = glist_up, N = N)
rra_down <- aggregateRanks(glist = glist_down, N = N)

# Adjust p-values (FDR) directly on Score (recommended)
rra_up$Bonferroni <- pmin(rra_up$Score * k_up, 1)        # optional column
rra_up$Adjusted_P <- p.adjust(rra_up$Score, method = "fdr")

rra_down$Bonferroni <- pmin(rra_down$Score * k_down, 1)
rra_down$Adjusted_P <- p.adjust(rra_down$Score, method = "fdr")

# ============================================================
# 6) Build matrix of logFCs (NA for missing) — safe fill (no <<- usage)
# ============================================================
unique_genes_all <- unique(c(gse_de[[sheets[1]]]$Gene.symbol,
                             gse_de[[sheets[2]]]$Gene.symbol,
                             gse_de[[sheets[3]]]$Gene.symbol))

mat <- matrix(NA, nrow = length(unique_genes_all), ncol = length(sheets),
              dimnames = list(unique_genes_all, sheets))

# Fill matrix using match to be safe & vectorized
for (s in sheets) {
  df <- gse_de[[s]]
  if ("logFC" %in% colnames(df)) {
    idx <- match(df$Gene.symbol, rownames(mat))
    present <- which(!is.na(idx))
    mat[idx[present], s] <- df$logFC[present]
  } else {
    # If logFC missing, leave NAs (you may later use sign-matrix only)
    warning(paste("No logFC column in", s))
  }
}

# ============================================================
# 7) Merge logFC columns into RRA results (for reporting)
#    Round logFC for readability
# ============================================================
mat_df <- as.data.frame(mat)
mat_df$Gene.symbol <- rownames(mat_df)

rra_up_out <- rra_up %>%
  left_join(mat_df, by = c("Name" = "Gene.symbol")) %>%
  dplyr::rename(logFC_GSE36001 = !!sheets[1],
                logFC_GSE16088 = !!sheets[2],
                logFC_GSE42352 = !!sheets[3]) %>%
  mutate(across(starts_with("logFC_"), ~ round(.x, 2)))

rra_down_out <- rra_down %>%
  left_join(mat_df, by = c("Name" = "Gene.symbol")) %>%
  dplyr::rename(logFC_GSE36001 = !!sheets[1],
                logFC_GSE16088 = !!sheets[2],
                logFC_GSE42352 = !!sheets[3]) %>%
  mutate(across(starts_with("logFC_"), ~ round(.x, 2)))

# Write results to a single workbook with two sheets
wb <- createWorkbook()
addWorksheet(wb, "RRA_up")
addWorksheet(wb, "RRA_down")
writeData(wb, "RRA_up", rra_up_out)
writeData(wb, "RRA_down", rra_down_out)
saveWorkbook(wb, paste0(out_prefix, "_RRA_results88.xlsx"), overwrite = TRUE)
cat("Wrote:", paste0(out_prefix, "_RRA_results.xlsx\n"))

# ============================================================
# 8) Select top genes for heatmap (top by Adjusted_P then Score fallback)
# ============================================================
# decide how many top from each (change if you want): 
n_top_each <- 20

top_up <- head(rra_up_out[order(rra_up_out$Adjusted_P, rra_up_out$Score), ], n_top_each)$Name
top_down <- head(rra_down_out[order(rra_down_out$Adjusted_P, rra_down_out$Score), ], n_top_each)$Name
top_genes <- unique(c(top_up, top_down))
# If Adjusted_P all 1s, the ordering still falls back to Score (raw)
if (length(top_genes) == 0) {
  top_genes <- head(rra_up_out$Name[order(rra_up_out$Score)], n_top_each)
}

# Build mat_top; keep rownames in original gene order for clarity
mat_top <- mat[top_genes, , drop = FALSE]

# Replace NA with 0 only for display numbers if you want, but keep NA for clustering
display_mat_top <- mat_top
display_mat_top[is.na(display_mat_top)] <- NA  # pheatmap will show blank cells for NA

# For display numbers we will format values (round to 2 decimals) but convert NAs to empty strings
display_numbers <- matrix("", nrow = nrow(display_mat_top), ncol = ncol(display_mat_top),
                          dimnames = dimnames(display_mat_top))
num_idx <- which(!is.na(display_mat_top), arr.ind = TRUE)
for (i in seq_len(nrow(num_idx))) {
  r <- num_idx[i,1]; c <- num_idx[i,2]
  display_numbers[r, c] <- formatC(display_mat_top[r, c], digits = 2, format = "f")
}

# ============================================================
# 9) Plot combined logFC heatmap with numbers and angled cols
# ============================================================
# --- Clean matrix before clustering ---
mat_top <- as.matrix(mat_top)
mat_top[!is.finite(mat_top)] <- NA   # Replaces Inf/-Inf with NA
mat_top[is.na(mat_top)] <- mean(mat_top, na.rm = TRUE)  # Replace NA with the mean of mat_top, ignoring NAs

set.seed(42)
heatmap_colors <- colorRampPalette(c("#2e4057", "white", "#d1495b"))(50)


pheatmap(
  mat_top,
  color = heatmap_colors,
  breaks = seq(
    from = -max(abs(as.vector(mat_top)), na.rm = TRUE),
    to   =  max(abs(as.vector(mat_top)), na.rm = TRUE),
    length.out = length(heatmap_colors) + 1
  ),
  main = "LogFC of Top RRA Genes Across GSE Datasets",
  cluster_rows = FALSE,
  cluster_cols = TRUE,
  fontsize_row = 8,
  show_rownames = TRUE,
  na_col = "grey90",
  display_numbers = display_numbers,
  number_color = "black",
  angle_col = 45,
  fontsize_number = 8,
  border_color = NA,
  filename = paste0(out_prefix, "_logfc_heatmap22.png"),
  width = 8, height = 10, units = "in", res = 300
)

# ============================================================
# 10) Optional: sign-based matrix heatmap (Up / Neutral / Down)
# ============================================================
mat_sign <- sign(mat_top)   # -1, 0, 1; NA remains NA
# map to -1/0/1 colors
pheatmap(mat_sign,
         color = c("#2e4057", "white", "#d1495b"),
         breaks = c(-1.5, -0.5, 0.5, 1.5),
         main = "Regulation Sign of Top RRA Genes Across GSE Datasets",
         cluster_rows = FALSE,
         cluster_cols = TRUE,
         fontsize_row = 8,
         show_rownames = TRUE,
         legend_breaks = c(-1, 0, 1),
         legend_labels = c("Down", "Neutral", "Up"),
         angle_col = 45,
         filename = paste0(out_prefix, "_sign_heatmap.png"),
         width = 8, height = 10, units = "in", res = 300)

# ============================================================
# END
# ============================================================
cat("Done. Outputs:\n - RRA XLSX with logFC columns\n - PNG heatmaps\nTip: re-run with apply_filter = TRUE if you want stricter per-dataset DEG lists before ranking.\n")
